1. Campos de Filtrado para Películas: * Género(s): * UI: Lista de checkboxes con el mismo estilo "tag" que en form-pelicula.html. * Lógica: Selección múltiple. Las películas deben tener CUALQUIERA de los géneros seleccionados (OR). * Por Defecto: Ningún género seleccionado (implica que todas las películas pasan este filtro inicialmente). * Plataforma(s) de Streaming: * UI: Lista de checkboxes con logos (o texto fallback) como en form-pelicula.html. * Lógica: Selección múltiple. Las películas deben estar en CUALQUIERA de las plataformas seleccionadas (OR). * Por Defecto: Ninguna plataforma seleccionada (implica que todas las películas pasan este filtro inicialmente). * Rango de Año de Estreno: * UI: Dos sliders (o inputs de tipo "range") para seleccionar "Año Mínimo" y "Año Máximo". * Restricciones: El valor del slider "Año Mínimo" no podrá ser mayor que el del "Año Máximo", y viceversa. * Valores: Desde 1895 hasta el año actual. * Por Defecto: Rango completo (1895 - año actual). * Puntuación Mínima: * UI: Un único slider (o input de tipo "range") para seleccionar "Puntuación Mayor o Igual que". * Valores: De 0.0 a 10.0. * Por Defecto: 0.0.

2. Interfaz de Usuario (Sidebar - _sidebar.html): * Se añadirán los controles de formulario descritos arriba dentro de la sección del sidebar correspondiente a la página de películas (th:if="${currentPage == 'peliculas'}"). * Botón "Aplicar Filtros": Un botón al final de la sección de filtros. Al hacer clic, se disparará la solicitud HTMX. * Botón "Limpiar Filtros": Un botón al final de la sección de filtros. Al hacer clic: * Restablecerá todos los controles de filtro del sidebar a sus valores por defecto. * Disparará una solicitud HTMX sin parámetros de filtro (o con parámetros que indiquen "sin filtro") para recargar la lista completa. * Integración con HTMX: * El botón "Aplicar Filtros" será el que tenga los atributos hx-get, hx-target, hx-include (para incluir todos los campos de filtro y ordenación), y hx-push-url="true". * El botón "Limpiar Filtros" también usará HTMX para recargar la lista, posiblemente enviando parámetros que el backend interprete como "sin filtros" o simplemente no enviando parámetros de filtro. * Estado de los Filtros: El backend devolverá los valores de los filtros actualmente aplicados para que Thymeleaf pueda preseleccionar los checkboxes y ajustar los sliders al estado correcto después de cada recarga.

3. Backend - PeliculasController: * Recepción de Parámetros: El método mostrarPeliculas aceptará nuevos @RequestParam para: * List<Long> generoIds (opcional) * List<Long> plataformaIds (opcional) * Integer anioMin (opcional, con valor por defecto 1895) * Integer anioMax (opcional, con valor por defecto el año actual) * Float puntuacionMin (opcional, con valor por defecto 0.0) * Paso a Servicios: El controlador pasará estos parámetros de filtro, junto con los de ordenación (sortBy, sortDir), al PeliculaService. * Reflejo en URL: Los parámetros de filtro activos se incluirán en la URL.

4. Backend - PeliculaService: * Construcción de Consulta Dinámica: * Utilizará Spring Data JPA Specifications (Specification<Pelicula>). * Se construirán Specification individuales para cada criterio de filtro si el parámetro correspondiente está presente: * Para generoIds: pelicula.generos.id IN (:generoIds) (lógica OR implícita si se usa CriteriaBuilder.In). * Para plataformaIds: pelicula.plataformas.id IN (:plataformaIds) (lógica OR implícita). * Para anioMin y anioMax: pelicula.anioEstreno BETWEEN :anioMin AND :anioMax. * Para puntuacionMin: pelicula.puntuacion >= :puntuacionMin. * Estas Specification individuales se combinarán usando Specification.and(...) para lograr la lógica AND entre los diferentes tipos de filtro. * Llamada al Repositorio: Se llamará a peliculaRepository.findAll(Specification<Pelicula> spec, Sort sort).

5. Backend - PeliculaRepository: * Deberá extender JpaSpecificationExecutor<Pelicula> además de JpaRepository<Pelicula, Long>.

6. Flujo de Datos Combinado (Filtro + Ordenación): 1. Usuario configura los filtros (ej. Género "Drama", Año 2000-2010) y la ordenación (ej. Puntuación Descendente) en el sidebar. 2. Usuario hace clic en "Aplicar Filtros". 3. HTMX envía una solicitud GET a /peliculas con todos los parámetros de filtro y ordenación (ej. ?generoIds=X&anioMin=2000&anioMax=2010&puntuacionMin=0&sortBy=puntuacion&sortDir=desc). 4. PeliculasController recibe los parámetros. 5. El controlador los pasa a PeliculaService. 6. PeliculaService construye la Specification<Pelicula> combinada (filtros) y el objeto Sort (ordenación). 7. PeliculaService llama a peliculaRepository.findAll(specification, sort). 8. El repositorio ejecuta la consulta SQL que primero aplica las cláusulas WHERE (filtros) y luego ORDER BY (ordenación) sobre el resultado filtrado. 9. La lista de películas resultante se devuelve al servicio, luego al controlador. 10. El controlador añade la lista y los parámetros de filtro/ordenación actuales al Model. 11. Thymeleaf renderiza el fragmento HTML (peliculas-list-container) y el sidebar se actualiza para reflejar los filtros y la ordenación aplicados. La URL también se actualiza.

Consideraciones Adicionales: * Obtención de Año Actual: El backend necesitará una forma de obtener el año actual dinámicamente para el valor por defecto del filtro de año máximo y para el límite superior del slider. * Validación de Sliders: Asegurar que el "Año Mínimo" no supere al "Año Máximo" en la UI (JavaScript) y, opcionalmente, en el backend. * Disponibilidad de Géneros/Plataformas para Filtro: El sidebar necesitará que el controlador le pase la lista completa de allGeneros y allPlataformas para poder renderizar los checkboxes, similar a como lo hace AdminController para form-pelicula.html.